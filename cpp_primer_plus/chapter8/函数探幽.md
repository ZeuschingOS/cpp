## 第八章 函数探幽
### 8.1 c++内联函数

内联函数 与 宏定义

- 相同：两者都是在调用点展开。
- 不同：
  - 宏定义需要仔细考虑括号，否则可能产生意想不到的结果。
  - 内联函数也是函数，同样需要遵循变量的检查。比宏定义要有优势。

### 引用变量
引用只是变量的别名。
  - 指针与饮用的区别
  - 指针是一种数据类型，有单独的存储空间。
  - 引用不是任何一种数据类型，只是变量的别名。
  - 指针可以在任意时刻都重新赋值，可以更改指向的地址。
  - 变量在初始化时必须指定饮用的变量，且不可更改。

![Alt text](image.png)

例如上图：

定义一个变量a，引用ra，从栈上开辟一片空间用于存放变量a的地址，这个栈上的空间sp+24即表示引用ra。
后续所有对ra的使用都是栈上读取sp+24的内容及变量a的地址，再将内容写入到a的地址中。

### 引用与函数

- 入参是引用
- 函数返回类型是引用

![Alt text](image-1.png)

### 8.4 函数重载

### 8.5 函数模版

```
template <typename AnyType, typename Anytype2,....>
AnyType foo(AnyType parameter_foo)
{
  .....
  .....
  .....
  return;
}
```
- 关键字：template和typename
- 模版的参数也可以有多个，例如AnyType, AnyType2

#### 8.5.1 重载的模板
```
template <typename T1, typename T2>
T1 add(T1 a, T2 b)
{
    return a + b;
}

template <typename T>
T add(T a, T b, int c)
{
    return a + b + c;
}
```
#### 8.5.2 模板的局限性
 - 模板相对来讲比较固定，例如传入的参数不是整形，而是数组，则无法处理。或者传入的参数是结构体，这样也无法处理。
#### 8.5.3 显式具体化
假如定义如下结构
struct job
{
  char name[10];
  int salary;
  int floor;
}
假设只想将两个工资相加，而不是两个结构体对象相加。上述模板则无法处理。
解决方案是显式具体化。
#### 8.5.4 实例化与具体化
#### 8.5.5 编译器选择使用哪个函数版本